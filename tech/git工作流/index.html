<!doctype html><html lang=en><head><title>Git工作流 · 人渣29的小窝</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Harry Wang"><meta name=description content="多人开发同一代码时，如何处理"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Git工作流"><meta name=twitter:description content="多人开发同一代码时，如何处理"><meta property="og:title" content="Git工作流"><meta property="og:description" content="多人开发同一代码时，如何处理"><meta property="og:type" content="article"><meta property="og:url" content="https://harrywang29.github.io/tech/git%E5%B7%A5%E4%BD%9C%E6%B5%81/"><meta property="article:section" content="tech"><meta property="article:published_time" content="2022-05-13T22:15:31+08:00"><meta property="article:modified_time" content="2022-05-13T22:15:31+08:00"><link rel=canonical href=https://harrywang29.github.io/tech/git%E5%B7%A5%E4%BD%9C%E6%B5%81/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.c4d7e93a158eda5a65b3df343745d2092a0a1e2170feeec909b8a89443903c6a.css integrity="sha256-xNfpOhWO2lpls980N0XSCSoKHiFw/u7JCbiolEOQPGo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.102.1"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>人渣29的小窝</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/tech/>tech</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://harrywang29.github.io/tech/git%E5%B7%A5%E4%BD%9C%E6%B5%81/>Git工作流</a></h1></header><blockquote><p>git工作流其实含有很多种，git/github/gitlab等等，但是大多数文章中只是描述了主要流程中的特性，并没有描述多人并行开发时注意点，本文主要说明多人并行开发时，git如何使用</p></blockquote><h2 id=书籍推荐>书籍推荐
<a class=heading-link href=#%e4%b9%a6%e7%b1%8d%e6%8e%a8%e8%8d%90><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>首先推荐一本书——<a href=https://git-scm.com/book/zh/v2>git官方文档</a>，中文翻译+pdf下载，非常方便。</p><p>个人认为，作为普通使用者来讲，此书只需要看1/2/3/7就可以了，其他的可以作为扩展内容进行阅读，本文后续内容会有部分摘抄自此文档。</p><h2 id=前置知识>前置知识
<a class=heading-link href=#%e5%89%8d%e7%bd%ae%e7%9f%a5%e8%af%86><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>开源社区基础开发git流：</p><p><img src=https://user-images.githubusercontent.com/8288067/187078494-e08edc42-966f-46ea-be32-ce8a28c4e046.png alt=未命名文件.png></p><ol><li>从 <code>开源仓库</code>中fork到 <code>个人仓库</code></li><li>clone仓库到本地（其实这里无论是从原来仓库clone，还是从自己的仓库clone都可以，主要涉及本地remote如何设置）</li><li>在本地修改代码，实现需求</li><li>commit修改</li><li>push代码到 <code>个人仓库</code></li><li>从 <code>个人仓库</code> 发起pr到 <code>开源仓库</code></li><li>由 <code>开源仓库</code> 管理员审核后，merge 到 <code>开源仓库</code> 中</li><li>若开源仓库后续发布新的版本，则从 <code>开源仓库</code> pull到本地</li></ol><p>引申到公司代码开发：</p><p><img src=https://user-images.githubusercontent.com/8288067/187078911-625a840a-8fcd-425e-8aa5-d584f79f8c26.png alt=image></p><blockquote><p>最近在使用了企业版gitee后，发现评审模式下，员工对保护分支进行push时，会自动生成一个auto-xxx的pr分支（例如git push origin new-work => git push origin auto-new-work; 再从auto-new-work提交一个pr到new-work分支），观察下来发先，确实可以省去fork这一流程</p></blockquote><h2 id=分支>分支
<a class=heading-link href=#%e5%88%86%e6%94%af><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>相信大家对于创建分支命令已经非常熟悉了：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch test
</span></span><span style=display:flex><span>git checkout test
</span></span><span style=display:flex><span>或者
</span></span><span style=display:flex><span>git checkout -b test
</span></span></code></pre></div><p>在此推荐几个命令：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git branch --merged <span style=color:#75715e>#查看所有已经合并到当前分支的分支</span>
</span></span><span style=display:flex><span>git branch --no-merged <span style=color:#75715e>#查看所有包含未合并工作的分支</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#详细解释可以执行如下命令查看</span>
</span></span><span style=display:flex><span>git branch --help
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>git stash      <span style=color:#75715e># 将当前分支的改动储藏起来</span>
</span></span><span style=display:flex><span>               <span style=color:#75715e># 当你有一些代码改动，又不想commit时，可使用此命令将变动暂存起来</span>
</span></span><span style=display:flex><span>git stash pop  <span style=color:#75715e># 将最后一起储藏起来的变动释放出来</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#详细解释可以执行如下命令查看</span>
</span></span><span style=display:flex><span>git stash --help
</span></span></code></pre></div><p>此处我们还是查看文章 <strong><a href=https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6>3.2 Git 分支 - 分支的新建与合并</a></strong></p><h2 id=工作流>工作流
<a class=heading-link href=#%e5%b7%a5%e4%bd%9c%e6%b5%81><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>在 Git Flow 中，有两个长期存在且不会被删除的分支：master 和 develop。</p><p>在这两个分支中，master 主要用于对外发布稳定的新版本，该分支时常保持着软件可以正常运行的状态，由于要维护这一状态，所以不允许开发者直接对 master 分支的代码进行修改和提交，其他分支的开发工作进展到可以发布的程度后，将会与 master 分支进行合并，并且这一合并只在发版时进行，发布时将会附加版本编号的 Git 标签。</p><p>develop 则用来存放我们最新开发的代码，这个分支是我们开发过程中代码中心分支，这个分支也不允许开发者直接进行修改和提交。程序员要以 develop 分支为起点新建 feature 分支，在 feature 分支中进行新功能的开发或者代码的修正，也就是说 develop 分支维系着开发过程中的最新代码，以便程序员创建 feature 分支进行自己的工作。</p><p>注意 develop 合并的时候，不要使用 fast-farward merge，建议加上 &ndash;no-ff 参数，这样在 master 上就会有合并记录，关于这两个的区别，大家可以参数松哥之前的 Git 教程，这里不再赘述。</p><p>除了这两个永久分支，还有三个临时分支：feature branches、hotfixes 以及 release branches。</p><p>作者：陈琰AC
链接：<a href=https://www.jianshu.com/p/7eba1f0b5b42>https://www.jianshu.com/p/7eba1f0b5b42</a>
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>以上基本上都是引用现有的一些文字，现在我们看下实际开发情况：</p><p>我们假设下一个版本(v0.0.1)共有两个需求分别为feat1和feat2，现将需求分配给两个人分别为user1和user2。</p><p>问题：</p><p>按照当前的开发习惯，我们由管理员在公司仓库中，创建feat-0.0.1分支，两个人同时都在feat-0.0.1开发，拉取feat-0.0.1代码，将修改后的代码推送至feat-0.0.1，若这时user1负责的需求feat1因为一些不可抗力，被延迟一个版本甚至要求完全不上线，那么feat-0.0.1的代码已经完全搅和在一起了，我们只能让user1在feat-0.0.1中把feat1的代码自己删除，才能保证feat2正常的上线</p><p>解决：</p><ol><li>user1和user2分别在本地创建feat1和feat2的分支</li><li>各自在自己的分支中分别写入需求代码</li><li>需求完成开发后，要进入测试</li><li>在企业仓库中创建 <code>feat1</code> 和 <code>feat2</code> 分支</li><li>使用常用分支 <code>test</code> ，各自将分支代码通过pr合入 <code>test</code> 分支中</li><li>将 <code>test</code> 分支发布到test环境</li><li>测试人员开始测试</li><li>初步测试通过后，准备回归测试</li><li>创建 <code>release-0.0.1</code> 分支，将 <code>feat1</code> 和 <code>feat2</code> 代码合入</li><li>将 <code>release-0.0.1</code> 分支发到预发环境，并进行测试</li><li>测试完成，将 <code>release-0.0.1</code> 和入 <code>master</code> 分支并准备发版</li><li>删除 <code>release-0.0.1</code> 分支代码</li><li>创建 <code>v0.0.1</code> tag</li></ol><p>以上解决步骤看起来可能复杂，其实最后只有一条根本的原则， <code>feat1</code> 分支中不能包含 <code>feat2</code> 的任何代码，反之亦然，这样无论是任何原因导致了，需求无法上线，都可以快速的做出应对，解决了由于一些不可抗力导致代码回滚</p><h2 id=后记>后记
<a class=heading-link href=#%e5%90%8e%e8%ae%b0><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>这个方案在描述完成后，有小伙伴提出那我们仓库的分支岂不是会非常多？此处可使用<a href=#%E5%88%86%E6%94%AF>分支</a>中提到的命令查看是否有把分支合并到master/main分支中</p><p>如下是我之前一个开发的项目分支：</p><p><img src=https://user-images.githubusercontent.com/8288067/187079282-07459456-f4da-4bac-a578-c6d2c572e5c6.png alt=image></p></article></section></div><footer class=footer><section class=container>©
2022
Harry Wang
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JS09HCGHMW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JS09HCGHMW",{anonymize_ip:!1})}</script></body></html>