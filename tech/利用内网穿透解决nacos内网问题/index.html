<!doctype html><html lang=en><head><title>利用内网穿透解决nacos内网问题 · 人渣29的小窝</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Harry Wang"><meta name=description content="利用内网穿透解决nacos与服务在两个内网环境中时，无法互通的问题"><meta name=keywords content="blog,developer,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="利用内网穿透解决nacos内网问题"><meta name=twitter:description content="利用内网穿透解决nacos与服务在两个内网环境中时，无法互通的问题"><meta property="og:title" content="利用内网穿透解决nacos内网问题"><meta property="og:description" content="利用内网穿透解决nacos与服务在两个内网环境中时，无法互通的问题"><meta property="og:type" content="article"><meta property="og:url" content="https://harrywang29.github.io/tech/%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3nacos%E5%86%85%E7%BD%91%E9%97%AE%E9%A2%98/"><meta property="article:section" content="tech"><meta property="article:published_time" content="2022-08-30T20:51:52+08:00"><meta property="article:modified_time" content="2022-08-30T20:51:52+08:00"><link rel=canonical href=https://harrywang29.github.io/tech/%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3nacos%E5%86%85%E7%BD%91%E9%97%AE%E9%A2%98/><link rel=preload href="/fonts/forkawesome-webfont.woff2?v=1.2.0" as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.c4d7e93a158eda5a65b3df343745d2092a0a1e2170feeec909b8a89443903c6a.css integrity="sha256-xNfpOhWO2lpls980N0XSCSoKHiFw/u7JCbiolEOQPGo=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.39e41a7f16bdf8cb16e43cae7d714fa1016f1d2d2898a5b3f27f42c9979204e2.css integrity="sha256-OeQafxa9+MsW5DyufXFPoQFvHS0omKWz8n9CyZeSBOI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5><meta name=generator content="Hugo 0.102.3"></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>人渣29的小窝</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/tech/>tech</a></li></ul></section></nav><div class=content><section class="container page"><article><header><h1 class=title><a class=title-link href=https://harrywang29.github.io/tech/%E5%88%A9%E7%94%A8%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3nacos%E5%86%85%E7%BD%91%E9%97%AE%E9%A2%98/>利用内网穿透解决nacos内网问题</a></h1></header><h2 id=背景>背景
<a class=heading-link href=#%e8%83%8c%e6%99%af><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><h3 id=技术栈>技术栈
<a class=heading-link href=#%e6%8a%80%e6%9c%af%e6%a0%88><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>java</li><li>spring-cloud</li><li>nacos</li></ul><h3 id=办公地点>办公地点
<a class=heading-link href=#%e5%8a%9e%e5%85%ac%e5%9c%b0%e7%82%b9><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><ul><li>3个不同的省市自治区</li></ul><h2 id=问题>问题
<a class=heading-link href=#%e9%97%ae%e9%a2%98><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>由于开发环境部署在A市的机房中，于是其他市的开发就无法接入开发环境进行联调，特别是遇到B市的后端与C市的前端共同开发需求的情况。</p><p>核心问题其实就两个：</p><ol><li>A市外的机器要访问nacos把服务注册到nacos中</li><li>开发环境中gateway需要访问到外部的机器</li></ol><h2 id=解决方案>解决方案
<a class=heading-link href=#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>最后解决的时候发现，上面两个问题其实总结下来，依旧是内网穿透的问题，所以需要一个公网机器中转即可</p><h3 id=注册nacos>注册nacos
<a class=heading-link href=#%e6%b3%a8%e5%86%8cnacos><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>这一部分其实相对简单，因为开发过程中总要看看数据库什么的，所以很早就使用了frp进行内网穿透</p><p>frps配制，其实frps本身并没有什么特殊需要配制的东西，主要就是port和token注意一下就好</p><p>主要还是frpc部分</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ini data-lang=ini><span style=display:flex><span><span style=color:#a6e22e>...</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#frpc的基础部分，ip啊port啊这些就直接省略了</span>
</span></span><span style=display:flex><span><span style=color:#75715e>#增加ssh映射</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>[nacos]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>type</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>tcp</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>local_ip</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>192.168.0.15	#内网的ip地址，由于内网存在多台机器，我只需要将frpc安装在一台机器上，由此机器进行内网中转即可</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>local_port</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>2222				#内网机器端口</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>use_encryption</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>false	</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>use_compression</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>false</span>
</span></span><span style=display:flex><span><span style=color:#75715e># remote port listen by frps</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>remote_port</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>150			#公网机器开发的端口</span>
</span></span></code></pre></div><p>这样设置好之后，访问公网的150端口就可以访问到 <code>192.168.0.15</code>就可以访问15机器了</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>ssh -p150 root@111.111.111.111
</span></span></code></pre></div><p>此处可以使用 <code>ssh -D</code> 参数命令打开socks代理端口，由于我没有通过此方案，就没有拿到命令参数了</p><p>这里抛砖引玉一下，其实可以使用现有的一些软件，进行规则分流，比如我要访问 <code>192.168.0.15</code> 的时候，通过xx线路走</p><h3 id=gateway访问外网服务>gateway访问外网服务
<a class=heading-link href=#gateway%e8%ae%bf%e9%97%ae%e5%a4%96%e7%bd%91%e6%9c%8d%e5%8a%a1><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h3><p>这个确实困扰我了好久，可以说好几个月了，主要还是以前我们这里负责的需求都是从mq里获取数据，正好不用通过gateway来转发，所以也一直没怎么上心</p><p>最近接的需求各种支付宝/微信的http异步通知，调试起来太痛苦了，前两天在看 <a href=https://github.com/snail007/goproxy>goproxy</a> 文档的时候，突然意识到一个问题，gateway访问我不也是一个内网穿透么？我是内网，他访问我罢了，于是反向做一个内网穿透做一个就好了</p><p>goproxy<a href="https://snail007.github.io/goproxy/manual/zh/#/?id=_4%e5%86%85%e7%bd%91%e7%a9%bf%e9%80%8f">详细文档</a></p><p>在这里我使用了高级用法一的方案</p><ol><li>公网机器执行</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>proxy bridge -p <span style=color:#e6db74>&#34;:33080&#34;</span> -C proxy.crt -K proxy.key
</span></span></code></pre></div><ol start=2><li>A市内网<code>192.168.0.15</code>机器上执行</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>proxy server -r <span style=color:#e6db74>&#34;:19551@:9551&#34;</span> -P <span style=color:#e6db74>&#34;111.111.111.111:33080&#34;</span> -C proxy.crt -K proxy.key
</span></span></code></pre></div><ol start=3><li>开发机器上执行</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>proxy client -P <span style=color:#e6db74>&#34;111.111.111.111:33080&#34;</span> -C proxy.crt -K proxy.key
</span></span></code></pre></div><ol start=4><li>设置spring-cloud微服务启动参数</li></ol><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>java  ... -Dspring.cloud.nacos.discovery.ip<span style=color:#f92672>=</span>192.168.0.15 -Dspring.cloud.nacos.discovery.port<span style=color:#f92672>=</span><span style=color:#ae81ff>19551</span> -Dspring.cloud.nacos.discovery.metadata.version<span style=color:#f92672>=</span>test ...
</span></span><span style=display:flex><span><span style=color:#75715e># 此处主要是修改在nacos注册时的ip/port/version</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 修改启动命令而不是配置文件，主要原因还是这个配制过于本地化了，并不通用免得不小心提交了</span>
</span></span><span style=display:flex><span><span style=color:#75715e># idea可以直接设置vm参数来进行</span>
</span></span><span style=display:flex><span><span style=color:#75715e># 这里的version也说明一下，主要用于与前端联调，在gateway收到请求后，会通过version向nacos获取实例，让前端与你联调时，指定verion，这样可以保证请求只会打到你个人的机器上</span>
</span></span></code></pre></div><h4 id=工作原理>工作原理
<a class=heading-link href=#%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86><i class="fa fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h4><ol><li>在<code>nacos</code>上注册服务的ip/port为 <code>192.168.0.15:19551</code></li><li><code>gateway</code>需要转发时，问<code>nacos</code>拿到的ip/port为<code>192.168.0.15:19551</code></li><li>由于已经架设了<code>proxy</code>于是向<code>192.168.0.15:19551</code>地址发送的请求，都被proxy转发到了<code>111.111.111.111:33080</code>地址</li><li><code>111.111.111.111</code>上的<code>proxy bridge</code>会看有哪些的<code>client</code></li><li><code>111.111.111.111</code>将内网的请求转发到<code>client</code>上</li><li><code>client</code>收到请求后，由于设置了<code>":19551@:9551"</code>，于是client把请求转发到本地<code>9551</code>接口上</li></ol><p>至此功能完成</p></article></section></div><footer class=footer><section class=container>©
2022
Harry Wang
·
Powered by <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/coder.min.236049395dc3682fb2719640872958e12f1f24067bb09c327b233e6290c7edac.js integrity="sha256-I2BJOV3DaC+ycZZAhylY4S8fJAZ7sJwyeyM+YpDH7aw="></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-JS09HCGHMW"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-JS09HCGHMW",{anonymize_ip:!1})}</script></body></html>