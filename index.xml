<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>人渣29的小窝</title><link>https://harrywang29.github.io/</link><description>Recent content on 人渣29的小窝</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 28 Aug 2022 23:17:00 +0800</lastBuildDate><atom:link href="https://harrywang29.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Git Log Alias</title><link>https://harrywang29.github.io/tech/git-log-alias/</link><pubDate>Sun, 28 Aug 2022 23:17:00 +0800</pubDate><guid>https://harrywang29.github.io/tech/git-log-alias/</guid><description>设置 Link to heading git config --global alias.lg &amp;#34;log --color --graph --pretty=format:&amp;#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&amp;lt;%an&amp;gt;%Creset&amp;#39; --abbrev-commit&amp;#34; 效果 Link to heading base on gorm</description></item><item><title>利用nginx变通的解决跨域问题</title><link>https://harrywang29.github.io/tech/%E5%88%A9%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%86%E6%B5%81/</link><pubDate>Fri, 26 Aug 2022 22:11:20 +0800</pubDate><guid>https://harrywang29.github.io/tech/%E5%88%A9%E7%94%A8nginx%E8%BF%9B%E8%A1%8C%E9%A1%B5%E9%9D%A2%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%88%86%E6%B5%81/</guid><description>背景 Link to heading 支付宝商家会员卡业务有两种开卡方式（此处不考虑最新的spi方式）
支付宝app扫投放链接获取会员卡 支付宝小程序通过会员卡参数直接拉起小程序开卡组件 这两个方式在用户填写表单之后都会向指定回调地址中发送一个get请求，并等待成功返回
如果为了兼容上面两种开卡方式，最优选择应该是后端接收到支付宝的get请求后，通过out_string判断是由什么渠道发起的
若浏览器发起，在开卡业务完成后，返回301/302重定向应答，让支付宝app重定向到一个前端页面进行展示 若小程序发起，则返回应答成功的业务报文即可 可是目前我们后端框架暂时无法支持向前端返回301/302这种重定向应答，于是我们暂时只支持了小程序开卡方式
一天支付宝业务人员突然说，他们需要h5扫码方式开会员卡，印刷并张贴在商户门店中，做一些运营活动，很突然，并且当天就要，还要app端跳转到卡包中，于是有了后面的一些操作
解决方案 Link to heading 难点 Link to heading 如上文所说，我们后端并不支持返回301/302应答码，同时也不能导致支付宝小程序发卡失败，那么我们就只有一个方法解决问题，分成两个步骤：
写一个中转页面，在h5模式下，支付宝app会解析html页面，于是中转页面中不需要有任何的界面，业务也比较简单 获取get请求中的query参数 将参数作为get参数发送给后端 获取请求结果 若应答成功，herf到指定scheme_url中 由于紧急，并且公司内部的一些原因，要在公司主域名下发这个中转页面变得不太现实，于是引发了另外一个问题，跨域 解决 Link to heading 解决第一个问题非常方便，找了个前端，花几分钟完成了核心代码，一个html文件解决 第二个问题曾一度陷入死胡同，最后一句闲聊启发了我，为了避免跨域，html只能向自己域发起请求，那么我只需要找个东西在html的域下把get请求转发到后端就可以了，查阅了文档后，直接使用nginx即可做到 location /ali { #判断$query_string中是否有web标识 if ( $query_string ~* &amp;#34;.*ali_web_redirect.*&amp;#34; ) { #有web标识，则跳转到中转页面 return 301 https://$http_host/redirect/redirect.html?$query_string; } #没有则直接向后端发送请求 proxy_pass https://www.host.com/api/member/open/alipay/opencard; } location /redirect/ { root /opt/www/ali-redirect; index index.html index.htm; } #这个是中转页面发起的请求，此域名收到后，会转发到公司后端 location ^~ /api/ { proxy_pass https://www.</description></item><item><title>突破vuepress Theme Reco 1.x的密码限制</title><link>https://harrywang29.github.io/tech/%E7%AA%81%E7%A0%B4vuepress-theme-reco-1.x%E7%9A%84%E5%AF%86%E7%A0%81%E9%99%90%E5%88%B6/</link><pubDate>Fri, 26 Aug 2022 22:07:01 +0800</pubDate><guid>https://harrywang29.github.io/tech/%E7%AA%81%E7%A0%B4vuepress-theme-reco-1.x%E7%9A%84%E5%AF%86%E7%A0%81%E9%99%90%E5%88%B6/</guid><description>起因 Link to heading 在这个blog准备架设的时候，查看了一个前端同事的blog，他的架设方式为：
github action vurpress 在观察他blog的过程中，他提到了有一个文档是属于加密状态，此时作为一个后端开发，我立刻想到了一个问题，你一个纯前端页面，如何能够保证自己的密码安全？
挑战 Link to heading 在我提出质疑之后，前端同事向我提出了挑战，让我看看是否能够看到里面的内容，作为一个喜欢瞎折腾的人，必然接受了挑战
解决方案 Link to heading github-master Link to heading 由于他是基于github+action，那么我非常简单的就找到了文本内容，步骤如下：
打开仓库首页 确认master分支 找到文档存储位置 点开文档 好了，非常简单，因为action的原因，你必须要将自己的文档完全的放入仓库中，action才能进行编译等操作 但是此时看到内容，我总感觉没啥意思，好了，开始给自己加活
github-gh-pages Link to heading 其实这个方法的原理和master的方法一样，都是有源码的情况下，能够看到静态的html，流程如下：
打开仓库首页 确认gh-pages分支 找到文档存储位置 点开文档 依旧非常简单，我们在html中看到了文本的正文
以上两种其实算是我知道他源码仓库的情况下，假设他修改了blog域名，我不知道他的github仓库，那么我要如何操作呢？
chrome-&amp;gt;view page source Link to heading 祭出chrome（其实firefox什么的都一样，没有什么复杂的东西）
打开blog加密页
界面如下 view page source
到这一步大家应该发现了，其实这里的page和上面的gh-pages中一样了，html文件中写着正文
其实到这里我本来不想再进行下去了，不过一直没有正式的把Konck!Knock!干掉总也有点不甘心
chrome替换js大法 Link to heading 查看vuepress-theme-reco-1.x关于密码部分源码，发现密码的校验与生成也是非常简单
const isHasPageKey = () =&amp;gt; { const pageKeys = instance.$frontmatter.keys.map(item =&amp;gt; item.</description></item><item><title>Git工作流</title><link>https://harrywang29.github.io/tech/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</link><pubDate>Fri, 13 May 2022 22:15:31 +0800</pubDate><guid>https://harrywang29.github.io/tech/git%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid><description>git工作流其实含有很多种，git/github/gitlab等等，但是大多数文章中只是描述了主要流程中的特性，并没有描述多人并行开发时注意点，本文主要说明多人并行开发时，git如何使用
书籍推荐 Link to heading 首先推荐一本书——git官方文档，中文翻译+pdf下载，非常方便。
个人认为，作为普通使用者来讲，此书只需要看1/2/3/7就可以了，其他的可以作为扩展内容进行阅读，本文后续内容会有部分摘抄自此文档。
前置知识 Link to heading 开源社区基础开发git流：
从 开源仓库中fork到 个人仓库 clone仓库到本地（其实这里无论是从原来仓库clone，还是从自己的仓库clone都可以，主要涉及本地remote如何设置） 在本地修改代码，实现需求 commit修改 push代码到 个人仓库 从 个人仓库 发起pr到 开源仓库 由 开源仓库 管理员审核后，merge 到 开源仓库 中 若开源仓库后续发布新的版本，则从 开源仓库 pull到本地 引申到公司代码开发：
最近在使用了企业版gitee后，发现评审模式下，员工对保护分支进行push时，会自动生成一个auto-xxx的pr分支（例如git push origin new-work =&amp;gt; git push origin auto-new-work; 再从auto-new-work提交一个pr到new-work分支），观察下来发先，确实可以省去fork这一流程
分支 Link to heading 相信大家对于创建分支命令已经非常熟悉了：
git branch test git checkout test 或者 git checkout -b test 在此推荐几个命令：
git branch --merged #查看所有已经合并到当前分支的分支 git branch --no-merged #查看所有包含未合并工作的分支 #详细解释可以执行如下命令查看 git branch --help git stash # 将当前分支的改动储藏起来 # 当你有一些代码改动，又不想commit时，可使用此命令将变动暂存起来 git stash pop # 将最后一起储藏起来的变动释放出来 #详细解释可以执行如下命令查看 git stash --help 此处我们还是查看文章 3.</description></item></channel></rss>